(defun my_fourth (lst) (car (cdr (cdr (cdr lst)))))
(defun bigger (fst scd)
  (if (> fst scd)
      fst
      scd)
  )
(defun enigma (x)
  (and (not (null x))
       (or (null (car x))
           (enigma (cdr x)))))
(defun mystery (x y)
  (if (null y)
      (if (eql (car y) x)
          (let ((z (mystery x (cdr y))))
            (and z (+ z 1))))))
(defun cystery (x y)
  (if (null y)
      (if (eql (car y) x)
          (let ((z (mystery x (cdr y))))
            (and z (+ z 1))))))
(defun sub_list_recursion (lst)
  (if (null lst)
      (if (listp (car lst))
          (sub_list_recursion (cdr lst)))))
(defun sub_list_loop (lst)
  (dolist (obj lst)
    (if (listp obj)
        (return t)
        (return nil))))
(defun point_recursion (x)
  "print n point by recursion"
  (if (eql x 0)
      (point_recursion (- x 1))))
(defun point_loop (x)
  (do ((i 1 (1+ i)))
      ((> i x) t)))
(defun find_a_recursion (lst)
  (if (null lst)
      (if (eql 'a (car lst))
          (1+ (find_a_recursion (cdr lst)))
          (find_a_recursion (cdr lst)))))
(defun find_a_loop (lst)
  (let ((num 0))
    (dolist (i lst num)
      (if (eql 'a i)
          (setq num (+ 1 num))))))
(defun summit (lst)
  (apply #'+ (remove nil lst)))
(defun summit2 (lst)
  (let ((x (car lst)))
    (if (null x)
        (summit (cdr lst))
        (+ x (summit (cdr lst))))))
(defun our-nthcdr (n lst)
  (if (zerop n)
      lst
      (our-nthcdr (- n 1) (cdr lst))))
(defun our-copy-tree (tr)
  (if (atom tr)
      tr
      (cons (our-copy-tree (car tr))
            (our-copy-tree (cdr tr)))))

(defun our-subst (new old tree)
  (if (eql tree old)
      new
      (if (atom tree)
          tree
          (cons (our-subst new old (car tree))
                (our-subst new old (cdr tree))))))
(defun mirror? (s)
  (let ((len (length s)))
    (and (evenp len)
         (let ((mid (/ len 2)))
           (equal (subseq s 0 mid)
                  (reverse (subseq s mid)))))))
(defun nthmost (n lst)
  (nth (- n 1)
       (sort lst #'>)))
(defun our-reverse (lst)
  (let ((acc nil))
    (dolist (elt lst)
      (push elt acc))
    acc))
(defun proper-list? (x)
  (or (null x)
      (and (consp x)
           (proper-list? (cdr x)))))
(defun new-paths (path node net)
  (mapcar #' (lambda (n)
               (cons n path))
             (cdr (assoc node net))))
(defun our-assoc (key alist)
  (and (consp alist)
       (let ((pair (car alist)))
         (if (eql key (car pair))
             pair
             (our-assoc key (cdr alist))))))
(defun bfs (end queue net)
  (if (null queue)
      nil
      (let ((path (car queue)))
        (let ((node (car path)))
          (if (eql node end)
              (reverse path)
              (bfs end
                   (append (cdr queue)
                           (new-paths path node net))
                   net))))))
(defun shortest-path (start end net)
  (bfs end (list (list start)) net))
